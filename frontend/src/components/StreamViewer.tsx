"use client";
import {
  forwardRef,
  useImperativeHandle,
  useRef,
  useState,
  useEffect,
} from "react";
import { FileText, Terminal, Zap } from "lucide-react";
import AgentTimeline, { AgentTimelineStep } from "./AgentTimeline";
import { Badge } from "@/components/ui/badge";

/* ------------------------------------------------------------------
   Types
-------------------------------------------------------------------*/
type Line = {
  node: string;
  state: any;
  timestamp: Date;
};

type AgentStep = {
  name: string;
  status: 'pending' | 'active' | 'completed' | 'error';
  description?: string;
  icon: React.ElementType;
};

/* ------------------------------------------------------------------
   Composant principal
-------------------------------------------------------------------*/
interface StreamViewerProps {
  timelineSteps: AgentTimelineStep[];
}

const StreamViewer = forwardRef<any, StreamViewerProps>(({ timelineSteps }, ref) => {
  const [lines, setLines] = useState<Line[]>([]);
  const [steps, setSteps] = useState<AgentStep[]>([
    { name: 'plan', status: 'pending', description: 'Planification', icon: FileText },
    { name: 'execute', status: 'pending', description: 'Ex√©cution', icon: Terminal },
    { name: 'write', status: 'pending', description: 'R√©daction', icon: Zap },
  ]);
  const [glowingStep, setGlowingStep] = useState<string | null>(null);
  const innerRef = useRef<HTMLPreElement>(null);

  useEffect(() => {
    if (glowingStep) {
      const timer = setTimeout(() => setGlowingStep(null), 1500);
      return () => clearTimeout(timer);
    }
  }, [glowingStep]);

  useImperativeHandle(ref, () => ({
    push({ node, state }: { node: string; state: any }) {
      console.log("StreamViewer received chunk:", { node, state }); // DEBUG

      setLines(ls => [...ls, { node, state, timestamp: new Date() }]);

      setGlowingStep(node);

      setSteps(prevSteps => {
        const newSteps = prevSteps.map(s => ({ ...s }));
        const currentStepIndex = newSteps.findIndex(s => s.name === node);
        if (currentStepIndex === -1) return prevSteps;

        return newSteps.map((step, index) => {
          if (index < currentStepIndex) return { ...step, status: 'completed' };
          if (index === currentStepIndex) {
            if (node === 'write' && state?.result) {
              return { ...step, status: 'completed' };
            }
            return { ...step, status: 'active' };
          }
          return { ...step, status: 'pending' };
        });
      });

      setTimeout(() => {
        const el = innerRef.current;
        if (el) el.scrollTop = 0;
      }, 0);
    },
    clear() {
      setLines([]);
      setSteps(prev => prev.map(s => ({ ...s, status: 'pending' })));
      setGlowingStep(null);
    }
  }));

  const renderContent = (node: string, state: any) => {
    if (!state) {
      return <span className="text-gray-500">G√©n√©ration du contenu...</span>;
    }

    switch (node) {
      case 'plan':
        return (
          <div className="space-y-2">
            <div className="text-blue-400 font-semibold text-sm">üìã Plan g√©n√©r√©</div>
            <ul className="space-y-1 pl-4">
              {state.plan?.steps?.map((step: any, i: number) => (
                <li key={i} className="text-gray-300 text-sm flex items-start">
                  <span className="text-blue-400 mr-2">‚Ä¢</span>
                  <span className="font-medium text-white mr-2">
                    {typeof step === 'string' ? `√âtape ${i + 1}:` : `${step.title}:`}
                  </span>
                  <span>{typeof step === 'string' ? step : step.description}</span>
                </li>
              ))}
            </ul>
          </div>
        );
      case 'execute':
        return (
          <div className="space-y-2">
            <div className="text-yellow-400 font-semibold text-sm">‚ö° Ex√©cution</div>
            <div className="bg-gray-900 p-3 rounded text-sm border-l-2 border-yellow-400">
              <pre className="text-gray-200 whitespace-pre-wrap font-mono text-xs leading-relaxed">
                {state.command || state.exec_result?.stdout || JSON.stringify(state, null, 2)}
              </pre>
            </div>
            {state.stderr && (
              <div className="text-red-400 text-sm bg-red-900/20 p-2 rounded border-l-2 border-red-400">
                <span className="font-medium">Erreur:</span> {state.stderr}
              </div>
            )}
          </div>
        );
      case 'write':
        return (
          <div className="space-y-2">
            <div className="text-green-400 font-semibold text-sm">‚úÖ R√©sultat final</div>
            <div className="relative rounded border-l-2 border-green-400 bg-green-900/20 p-3">
              <Badge
                className="absolute right-2 top-2 text-[10px]"
                variant="secondary"
              >
                Generated by AI
              </Badge>
              <div className="text-gray-200 text-sm whitespace-pre-wrap">
                {state.result || JSON.stringify(state, null, 2)}
              </div>
            </div>
          </div>
        );
      default:
        return <span className="text-gray-400 text-sm">Traitement en cours...</span>;
    }
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between bg-gray-800 p-3 rounded-lg">
        {steps.map((step) => {
          const Icon = step.icon;
          const isGlowing = glowingStep === step.name;
          const colors = {
            pending: "text-gray-500",
            active: "text-blue-400 animate-pulse",
            completed: "text-green-400",
            error: "text-red-400",
          };
          return (
            <div key={step.name} className={`flex items-center gap-2 p-2 rounded-md ${colors[step.status]} ${isGlowing ? 'animate-glow' : ''}`}>
              <Icon size={16} />
              <span className="text-sm font-medium">{step.description}</span>
            </div>
          );
        })}
      </div>

      <AgentTimeline steps={timelineSteps} />

      <pre
        ref={innerRef}
        className="bg-black p-4 h-80 overflow-y-auto rounded-lg text-xs font-mono"
      >
        {[...lines].reverse().map(({ node, state, timestamp }, i) => (
          <div key={lines.length - 1 - i} className="flex gap-3 items-start mb-2">
            <span className="text-gray-400 text-xs min-w-[60px]">{timestamp.toLocaleTimeString()}</span>
            <div className="flex-1">{renderContent(node, state)}</div>
          </div>
        ))}
      </pre>
    </div>
  );
});

StreamViewer.displayName = "StreamViewer";
export default StreamViewer;
